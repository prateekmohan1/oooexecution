//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/asu.edu/users/p/m/o/pmohan6/EEE591Brunhav/ProjPart4/Submission/primitives/top_mipsCore.vp
//  Source template: top_mipsCore
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/////////////
// top_seqDiv.vp

//`include "seqMult.v"
//`include "seqDiv.v"
`include "alu.v"
//`include "dff.v"
`include "dffbW_unq1.v"
`include "dffbW_unq2.v"
`include "dffbW_unq3.v"
`include "dffbW_unq4.v"
`include "dffbW_unq5.v"
`include "dffbW_unq6.v"
`include "dffbW_unq7.v"
//`include "bpredict.v"
//`include "dCache.v"
`include "OOOcontrol.v"
`include "rat.v"
`include "res_station.v"
`include "rob.v"
`include "fairArb.v"

// Top module without inputs or outputs
module top_OOOcontrol 
	#(parameter REG_BITS = 5,	//This is number of bits for storage
	  parameter CODE_BITS = 5,
	  parameter ROBID_BITS = 7,
	  parameter VALUE_SIZE = 32,
	  parameter NUM_STATIONS = 3,
	  parameter TYPE_INSTR = 4,
	  parameter NUM_ROWS_ROB = 128,
	  parameter OPCODE_SIZE = 20
	)
	();

  // To instantiate a module, first you have to 
  // generate the module and then instantiate it

  //Globals
  logic clk;
  logic rst;
  logic start;
  logic stop;
  logic stall;

  logic triggerStart, foo;


  logic [REG_BITS-1:0] r1addr, r2addr, waddr;
  logic [TYPE_INSTR-1:0] type_instr;
  logic [VALUE_SIZE-1:0] immed_val;
  logic [VALUE_SIZE-1:0] instrCount;
  logic [VALUE_SIZE-1:0] memiCache [479:0];
  logic [VALUE_SIZE-1:0] PC_count;
  logic [VALUE_SIZE-1:0] curr_instr;
  logic [VALUE_SIZE-1:0] instr;

  initial begin
    clk = 0;
	PC_count = 0;
  end

  always begin
    #250 clk = ~clk;
  end

  OOOControl OOOControl_engine(
	.r1addr(r1addr),
	.r2addr(r2addr),
	.waddr(waddr),
	.type_instr(type_instr),
	.immed_val(immed_val),
	.instr(curr_instr),
	.clk(clk),
	.rst(rst),
	.stall(stall)
  );

  initial begin
    $dumpfile("dump.vcd");
    $dumpvars(0, top_OOOcontrol);
  end  


  always begin
    @(negedge clk) begin
		if (!stall) begin
			PC_count = PC_count + 1;
		end
    end
  end

  always begin
    @(posedge clk) begin
	  if (rst == 1) begin
        curr_instr = memiCache[PC_count];
		if (curr_instr[31:26] == 6'b000000) begin
			if (curr_instr[5:0] == 6'b000000 || curr_instr[5:0] == 6'b000011 || curr_instr[5:0] == 6'b001000) begin
				//SLL, SRA, JR
				type_instr = 1;
				r1addr = curr_instr[25:21];
				immed_val = curr_instr[10:6];
				waddr = curr_instr[20:16];
			end
			else begin
				// ADD, AND, NOR, OR, SLT, SUB, XOR, ADDU
				type_instr = 0;
				r1addr = curr_instr[25:21];
				r2addr = curr_instr[20:16];
				waddr = curr_instr[15:11];
			end
		end
		else begin
			if (curr_instr[31:26] == 6'b100011 || curr_instr[31:26] == 6'b101011) begin
				//LW, SW
				type_instr = 2;
			end 
			else if (curr_instr[31:26] == 6'b000100 || curr_instr[31:26] == 6'b000111 || curr_instr[31:26] == 6'b000101 || curr_instr[31:26] == 6'b000010) begin
				//BEQ, BGTZ, BNE, J
				type_instr = 3;
			end
			else begin
				//ADDI, ANDI, ADDIU, ORI, SLTI, XORI, LUI
				type_instr = 1;
				r1addr = curr_instr[25:21];
				waddr = curr_instr[20:16];
				immed_val = curr_instr[15:0];
			end
		end
		//if (!stall) begin
		//	PC_count = PC_count + 1;
		//end
	  end
    end
  end

  task init_mem (inout logic [31:0] iCache [479:0], inout logic rst);
  
  	int i, j;
  	int data_file;
  	int scan_file;
  	logic [31:0] captured_data;
  
  	rst = 1;
  
  	//Populate the I$
  	data_file = $fopen("min_test","r");
  	for (i = 0; i < 10000; i++) begin
  		scan_file = $fscanf(data_file,"%h\n", captured_data);
  		if ($feof(data_file)) begin
  			instrCount = i;
  			break;
  		end
  		j = i;
  		iCache[j] = captured_data;
  		$display("memiCache[%d] is %h",j,iCache[j]);
  	end
  
  endtask

  initial begin
    triggerStart = 1'b0;

	init_mem(memiCache, rst);

	#230;
	rst = 1'b0;
	triggerStart = 1'b1;

	#500;
	rst = 1'b1;
  end

  initial begin
    foo = 1'b0;
    #1;
    @( posedge triggerStart );
      #100000;
      foo = 1'b1;

   $finish();
  end

endmodule:top_OOOcontrol
